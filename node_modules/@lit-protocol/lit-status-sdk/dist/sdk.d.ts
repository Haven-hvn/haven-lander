/**
 * Lit Status SDK
 *
 * A TypeScript SDK for interacting with the Lit Status monitoring server.
 * Provides methods to manage and monitor network functions across different products and networks.
 */
import { type OpenTelemetryConfig } from './telemetry';
export interface LitStatusClientConfig {
    /**
     * The base URL of the Lit Status server
     * @example "http://localhost:3000"
     */
    url: string;
    /**
     * API key for authentication (read-only or full access)
     */
    apiKey: string;
    /**
     * Optional custom fetch implementation
     */
    fetch?: typeof fetch;
    /**
     * OpenTelemetry configuration for enhanced observability
     * When enabled, provides distributed tracing, metrics, and structured logging
     * for the executeAndLog method
     */
    openTelemetry?: Partial<OpenTelemetryConfig>;
}
export interface CreateFunctionInput {
    name: string;
    network: string;
    product: string;
    description?: string;
    isActive?: boolean;
}
export interface MonitoredFunction {
    id: string;
    name: string;
    network: string;
    product: string;
    description?: string | null;
    isActive: boolean;
    createdAt: string;
    updatedAt: string;
    logs?: FunctionLog[];
}
export interface FunctionLog {
    id: string;
    functionId: string;
    isSuccess: boolean;
    errorMessage?: string | null;
    responseTimeMs?: number | null;
    createdAt: string;
}
export type LogExecutionInput = {
    isSuccess: true;
    errorMessage?: never;
    responseTimeMs?: number;
} | {
    isSuccess: false;
    errorMessage: string;
    responseTimeMs?: number;
};
export interface FunctionMetrics {
    functionId: string;
    totalExecutions: number;
    successfulExecutions: number;
    failedExecutions: number;
    averageResponseTime: number | null;
    uptime: number;
    lastExecutionTime: string | null;
}
export interface TimeRangeFilter {
    startDate?: Date | string;
    endDate?: Date | string;
}
export interface TimeBucket {
    timestamp: string;
    totalExecutions: number;
    successfulExecutions: number;
    failedExecutions: number;
    averageResponseTime: number | null;
    successRate: number;
}
export interface TimeSeriesMetrics {
    functionId: string;
    buckets: TimeBucket[];
    summary: FunctionMetrics;
    granularity: 'minute' | 'hour' | 'day' | 'week' | 'month';
    timeRange: {
        startDate: string;
        endDate: string;
    };
}
export interface HealthCheckResponse {
    status: string;
    connected: boolean;
}
export interface GetOrRegisterFunctionsInput {
    network: string;
    product: string;
    functions: string[];
    description?: string;
    isActive?: boolean;
}
export type GetOrRegisterFunctionsResult<T extends readonly string[]> = {
    [K in T[number]]: MonitoredFunction;
};
export interface MetricsExportFilters {
    network?: string;
    product?: string;
    function?: string;
    includeInactive?: boolean;
    startDate?: Date | string;
    endDate?: Date | string;
}
export interface MetricsExportResponse {
    metadata: {
        exportTime: string;
        totalFunctions: number;
        filters: {
            network: string | null;
            product: string | null;
            function: string | null;
        };
    };
    metrics: Array<{
        function: {
            id: string;
            name: string;
            network: string;
            product: string;
        };
        metrics: FunctionMetrics;
    }>;
}
export interface FilterOptionsResponse {
    networks: string[];
    products: string[];
    functions: string[];
    totalFunctions: number;
    activeFunctions: number;
    inactiveFunctions: number;
}
export interface LitStatusClient {
    /**
     * Check the health status of the server
     */
    healthCheck(): Promise<HealthCheckResponse>;
    /**
     * Create a new function or update an existing one
     */
    createOrUpdateFunction(input: CreateFunctionInput): Promise<MonitoredFunction>;
    /**
     * Initialise multiple functions at once
     * @param input - Configuration for batch function initialisation
     * @returns Object with function names as keys and MonitoredFunction objects as values
     *
     * @example
     * ```typescript
     * const txs = await client.getOrRegisterFunctions({
     *   network: 'testnet',
     *   product: 'test-product',
     *   functions: ['foo', 'bar']
     * });
     *
     * // Access functions by name
     * await client.logExecution(txs.foo.id, { isSuccess: true });
     * await client.executeAndLog(txs.bar.id, async () => { ... });
     * ```
     */
    getOrRegisterFunctions<T extends readonly string[]>(input: GetOrRegisterFunctionsInput & {
        functions: T;
    }): Promise<GetOrRegisterFunctionsResult<T>>;
    /**
     * Get a function by its name, network, and product
     */
    getFunction(name: string, network: string, product: string): Promise<MonitoredFunction | null>;
    /**
     * Get all functions
     * @param includeInactive - Whether to include inactive functions (default: false)
     */
    getAllFunctions(includeInactive?: boolean): Promise<MonitoredFunction[]>;
    /**
     * Log an execution for a function
     * @param functionId - The ID of the function
     * @param log - The execution log data
     */
    logExecution(functionId: string, log: LogExecutionInput): Promise<FunctionLog>;
    /**
     * Get metrics for a specific function
     * @param functionId - The ID of the function
     * @param timeRange - Optional time range filter
     */
    getFunctionMetrics(functionId: string, timeRange?: TimeRangeFilter): Promise<FunctionMetrics>;
    /**
     * Get metrics for all functions
     * @param timeRange - Optional time range filter
     */
    getAllMetrics(timeRange?: TimeRangeFilter): Promise<FunctionMetrics[]>;
    /**
     * Get time-series metrics for a specific function
     * @param functionId - The ID of the function
     * @param timeRange - Time range filter (defaults to last 24 hours)
     * @param granularity - Time bucket granularity (auto-selected if not specified)
     * @returns Time-series metrics with bucketed data for charting
     *
     * @example
     * ```typescript
     * // Get hourly metrics for the last 24 hours
     * const timeSeries = await client.getFunctionMetricsTimeSeries(
     *   functionId,
     *   { startDate: new Date(Date.now() - 24 * 60 * 60 * 1000) }
     * );
     *
     * // Get daily metrics for the last month
     * const monthlyMetrics = await client.getFunctionMetricsTimeSeries(
     *   functionId,
     *   { startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
     *   'day'
     * );
     *
     * // Chart the data
     * timeSeries.buckets.forEach(bucket => {
     *   console.log(`${bucket.timestamp}: ${bucket.successRate}% success rate`);
     * });
     * ```
     */
    getFunctionMetricsTimeSeries(functionId: string, timeRange?: TimeRangeFilter, granularity?: 'minute' | 'hour' | 'day' | 'week' | 'month'): Promise<TimeSeriesMetrics>;
    /**
     * Execute a function and automatically log its execution
     * @param functionId - The ID of the function to log for
     * @param fn - The async function to execute and monitor
     * @returns Object containing the result (if successful) and the created log
     *
     * @example
     * ```typescript
     * const { result, log } = await client.executeAndLog(
     *   functionId,
     *   async () => {
     *     const data = await fetchData();
     *     if (!data) throw new Error('No data found');
     *     return data;
     *   }
     * );
     * ```
     */
    executeAndLog<T>(functionId: string, fn: () => Promise<T>): Promise<{
        result?: T;
        log: FunctionLog;
    }>;
    /**
     * Export metrics in Prometheus format
     * @param filters - Optional filters for network, product, function, etc.
     * @returns Prometheus formatted metrics string
     *
     * @example
     * ```typescript
     * // Export all metrics in Prometheus format
     * const prometheusMetrics = await client.exportMetricsPrometheus();
     *
     * // Export filtered metrics
     * const filteredMetrics = await client.exportMetricsPrometheus({
     *   network: 'mainnet',
     *   product: 'lit-node'
     * });
     * ```
     */
    exportMetricsPrometheus(filters?: MetricsExportFilters): Promise<string>;
    /**
     * Export metrics in JSON format
     * @param filters - Optional filters for network, product, function, etc.
     * @returns Structured JSON metrics response
     *
     * @example
     * ```typescript
     * // Export all metrics in JSON format
     * const jsonMetrics = await client.exportMetricsJSON();
     *
     * // Export with time range and filters
     * const filteredMetrics = await client.exportMetricsJSON({
     *   network: 'testnet',
     *   startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
     *   endDate: new Date()
     * });
     * ```
     */
    exportMetricsJSON(filters?: MetricsExportFilters): Promise<MetricsExportResponse>;
    /**
     * Get available filter options for metrics export
     * @returns Available networks, products, functions and counts
     *
     * @example
     * ```typescript
     * const options = await client.getFilterOptions();
     * console.log('Available networks:', options.networks);
     * console.log('Available products:', options.products);
     * console.log('Total functions:', options.totalFunctions);
     * ```
     */
    getFilterOptions(): Promise<FilterOptionsResponse>;
}
declare class LitStatusError extends Error {
    statusCode?: number | undefined;
    response?: any | undefined;
    constructor(message: string, statusCode?: number | undefined, response?: any | undefined);
}
/**
 * Create a new Lit Status client
 *
 * @example
 * ```typescript
 * import { createLitStatusClient } from '@lit-protocol/lit-status-sdk';
 *
 * const client = createLitStatusClient({
 *   url: 'http://localhost:3000',
 *   apiKey: 'your-api-key'
 * });
 *
 * // Check server health
 * const health = await client.healthCheck();
 *
 * // Create or update a function
 * const func = await client.createOrUpdateFunction({
 *   name: 'myFunction',
 *   network: 'ethereum',
 *   product: 'myProduct',
 *   description: 'My monitoring function'
 * });
 * ```
 */
export declare function createLitStatusClient(config: LitStatusClientConfig): LitStatusClient;
export { LitStatusError };
//# sourceMappingURL=sdk.d.ts.map